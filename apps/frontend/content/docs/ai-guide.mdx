---
title: AI-Driven Guide
description: Optimize your workflow with LLMs by using the right tools and context strategies.
---

## 1. Living Documentation

This project uses a **Living Documentation** strategy. The documentation is code, located in `apps/frontend/content/docs/`.

<Callout title="The Golden Rule">
  "Whenever you make a significant architectural change or update a workflow, you MUST update the corresponding documentation page in the same PR."
</Callout>

### The Verification Workflow

To ensure the documentation stays in sync, the project uses automated checks:

<Steps>
### Detection
A dedicated script `./.gemini/scripts/verify-docs.sh` compares code changes with documentation updates.

### Security
The `Security-Check` tool (`verify-security.sh`) scans for secrets and unwanted files before commit.

### IA Mandate
The `.gemini/rules.md` forces the agent to run these checks before finalizing any task.

### Registry
These tools are registered in `.gemini/tools.md`.
</Steps>

#### How to use the workflow:

- **AI Agent**: Will automatically run `verify-docs.sh` and warn you if you forgot to document a feature.
- **Manual**: You can run the check anytime to see if your docs are lagging behind your features.

### Search Engine (Orama)

The documentation features a full-text search engine powered by [Orama](https://orama.com/).

- **Dynamic Indexing**: There is **no manual indexing step**. The search results are generated on-the-fly via the `/api/search` route.
- **Instant Sync**: As soon as you update an MDX file, the changes are reflected in the search results without rebuilding the application.
- **Granular Results**: The engine indexes content block by block, providing precise links to specific sections of the documentation.

## 2. Structured Feature Planning (Conductor)

This boilerplate uses the **Conductor** methodology to manage complex features through isolated units of work called **Tracks**.

### What is a Track?

A Track is a self-contained folder containing everything an AI agent needs to implement a specific goal:
- **`spec.md`**: The source of truth for requirements and acceptance criteria.
- **`plan.md`**: A step-by-step implementation guide with TDD requirements.
- **`metadata.json`**: Tracking state, priority, and timestamps.

### The Conductor Workflow

<Steps>
### Initialization
Use `conductor:newTrack` to define a new feature. The agent will collaboratively generate the specification and plan.

### Implementation
Run `conductor:implement --track <id>` to start the automated coding process. The agent will strictly follow the `plan.md`.

### Verification & Checkpointing
At the end of each phase, the agent executes a mandatory **Phase Completion Protocol**:
1. Automated tests run.
2. Manual verification steps are proposed to the user.
3. A **Checkpoint Commit** is created with an auditable verification report in Git Notes.
</Steps>

## 3. Recommended MCP Servers

The [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) connects the AI directly to your environment.

| Server | Benefit |
| :--- | :--- |
| Filesystem | Read/Write access. Crucial for this boilerplate. |
| [PostgreSQL](https://www.postgresql.org/) | Debug schemas/queries via `docker compose`. |
| GitHub | Context from Issues and PRs. |

## 3. Optimizing Context (.gemini)

The `.gemini/` folder is the "Brain" of your project context.

<Cards>
  <Card title="context.md">
    High-level architecture & stack details.
  </Card>
  <Card title="rules.md">
    Strict commandments (e.g. "No Prettier").
  </Card>
  <Card title="skills.md">
    Recipes for complex tasks (migrations, new routes).
  </Card>
</Cards>

## 4. Effective Prompting Strategies

<Callout title="Task: Scaffolding a Page">
  "I need a new Dashboard page at `/analytics`.
  1. Use the 'Server First' pattern.
  2. Create a skeleton loading state.
  3. Use the `Overview` component for charts.
  4. Follow `Layout` wrapper from `app/layout.tsx`.
  Check `@repo/shared` for DTOs."
</Callout>

<Callout title="Task: Generating Shadcn Component" type="info">
  "I need to add a `Tabs` component.
  1. Use the CLI: `pnpm dlx shadcn@latest add tabs` in the frontend directory.
  2. Verify the component is created in `components/ui`.
  3. Use it in the target page following existing patterns."
</Callout>
